<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 10);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const light = new THREE.AmbientLight(0xffffff, 0.8);
    scene.add(light);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
    dirLight.position.set(10, 20, 10);
    scene.add(dirLight);

    const floor = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), new THREE.MeshPhongMaterial({ color: 0x3a8e3a }));
    floor.rotation.x = -Math.PI / 2;
    scene.add(floor);

    // --- BUDOWA POSTACI Z RĘKAMI ---
    const player = new THREE.Group();
    const matYellow = new THREE.MeshPhongMaterial({color: 0xffff00});
    const matBlue = new THREE.MeshPhongMaterial({color: 0x0000ff});
    const matGreen = new THREE.MeshPhongMaterial({color: 0x00ff00});

    const head = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.7, 0.7), matYellow);
    head.position.y = 2.15;
    player.add(head);

    const torso = new THREE.Mesh(new THREE.BoxGeometry(1, 1.2, 0.5), matBlue);
    torso.position.y = 1.2;
    player.add(torso);

    // Nogi
    const legL = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1, 0.4), matGreen);
    legL.position.set(-0.3, 0.5, 0);
    player.add(legL);
    const legR = legL.clone();
    legR.position.set(0.3, 0.5, 0);
    player.add(legR);

    // Ręce
    const armL = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1, 0.4), matYellow);
    armL.position.set(-0.7, 1.3, 0);
    player.add(armL);
    const armR = armL.clone();
    armR.position.set(0.7, 1.3, 0);
    player.add(armR);

    scene.add(player);

    const controls = new OrbitControls(camera, renderer.domElement);
    const keys = {};
    document.addEventListener('keydown', (e) => keys[e.code] = true);
    document.addEventListener('keyup', (e) => keys[e.code] = false);

    let velocityY = 0;
    let walkCycle = 0; // Licznik animacji

    function animate() {
        requestAnimationFrame(animate);
        const direction = new THREE.Vector3();
        let isMoving = false;

        if (keys['KeyW'] || keys['ArrowUp']) { direction.z -= 1; isMoving = true; }
        if (keys['KeyS'] || keys['ArrowDown']) { direction.z += 1; isMoving = true; }
        if (keys['KeyA'] || keys['ArrowLeft']) { direction.x -= 1; isMoving = true; }
        if (keys['KeyD'] || keys['ArrowRight']) { direction.x += 1; isMoving = true; }

        if (isMoving) {
            direction.normalize();
            const angle = Math.atan2(camera.position.x - player.position.x, camera.position.z - player.position.z);
            direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
            player.position.addScaledVector(direction, 0.15);
            player.rotation.y = Math.atan2(direction.x, direction.z);

            // --- ANIMACJA CHODZENIA ---
            walkCycle += 0.15;
            const motion = Math.sin(walkCycle) * 0.5;
            
            // Machanie nogami
            legL.rotation.x = motion;
            legR.rotation.x = -motion;
            // Machanie rękami (odwrotnie do nóg)
            armL.rotation.x = -motion;
            armR.rotation.x = motion;
        } else {
            // Reset pozycji kończyn w bezruchu
            legL.rotation.x = 0;
            legR.rotation.x = 0;
            armL.rotation.x = 0;
            armR.rotation.x = 0;
        }

        if (keys['Space'] && player.position.y <= 0.01) velocityY = 0.2;
        player.position.y += velocityY;
        if (player.position.y > 0) velocityY -= 0.01;
        else { player.position.y = 0; velocityY = 0; }

        controls.target.copy(player.position.clone().add(new THREE.Vector3(0, 1.5, 0)));
        controls.update();
        renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
