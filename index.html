<script type="module">
    import * as THREE from 'three';

    // SCENA I RENDERER
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const light = new THREE.AmbientLight(0xffffff, 0.9);
    scene.add(light);

    // PODŁOGA
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), new THREE.MeshPhongMaterial({ color: 0x3a8e3a }));
    floor.rotation.x = -Math.PI / 2;
    scene.add(floor);

    // --- GRACZ (NOOB) ---
    const player = new THREE.Group();
    const yellowMat = new THREE.MeshPhongMaterial({color: 0xffff00});
    const blueMat = new THREE.MeshPhongMaterial({color: 0x0000ff});
    const greenMat = new THREE.MeshPhongMaterial({color: 0x00ff00});

    const torso = new THREE.Mesh(new THREE.BoxGeometry(1, 1.2, 0.6), blueMat);
    torso.position.y = 1.2;
    player.add(torso);

    const head = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.7, 0.7), yellowMat);
    head.position.y = 2.15;
    player.add(head);

    const armGeo = new THREE.BoxGeometry(0.4, 1, 0.4);
    const armL = new THREE.Mesh(armGeo, yellowMat);
    armL.position.set(-0.75, 1.3, 0);
    player.add(armL);
    const armR = armL.clone();
    armR.position.set(0.75, 1.3, 0);
    player.add(armR);

    const legGeo = new THREE.BoxGeometry(0.45, 1, 0.45);
    const legL = new THREE.Mesh(legGeo, greenMat);
    legL.position.set(-0.25, 0.5, 0);
    player.add(legL);
    const legR = legL.clone();
    legR.position.set(0.25, 0.5, 0);
    player.add(legR);

    scene.add(player);

    // --- NOWA LOGIKA KAMERY ---
    let cameraAngle = 0;
    let cameraDistance = 10;
    let isMouseDown = false;

    // Obsługa myszki do obracania kamerą
    document.addEventListener('mousedown', () => isMouseDown = true);
    document.addEventListener('mouseup', () => isMouseDown = false);
    document.addEventListener('mousemove', (e) => {
        if (isMouseDown) {
            cameraAngle -= e.movementX * 0.01;
        }
    });

    // STEROWANIE
    const keys = {};
    window.onkeydown = (e) => keys[e.code] = true;
    window.onkeyup = (e) => keys[e.code] = false;

    let walkTime = 0;

    function animate() {
        requestAnimationFrame(animate);
        let isMoving = false;
        const moveDir = new THREE.Vector3();

        // Poruszanie względem kąta kamery (tak jak w Roblox)
        if (keys['KeyW']) { moveDir.z = -1; isMoving = true; }
        if (keys['KeyS']) { moveDir.z = 1; isMoving = true; }
        if (keys['KeyA']) { moveDir.x = -1; isMoving = true; }
        if (keys['KeyD']) { moveDir.x = 1; isMoving = true; }

        if (isMoving) {
            moveDir.normalize();
            // Obracamy wektor ruchu o kąt kamery
            moveDir.applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraAngle);
            player.position.addScaledVector(moveDir, 0.15);
            
            // Postać obraca się płynnie w stronę ruchu
            const targetRotation = Math.atan2(moveDir.x, moveDir.z);
            player.rotation.y = targetRotation;

            walkTime += 0.2;
            const wave = Math.sin(walkTime) * 0.6;
            legL.rotation.x = wave; legR.rotation.x = -wave;
            armL.rotation.x = -wave; armR.rotation.x = wave;
        } else {
            legL.rotation.x = 0; legR.rotation.x = 0;
            armL.rotation.x = 0; armR.rotation.x = 0;
        }

        // --- AKTUALIZACJA KAMERY TPP ---
        const cameraTargetY = player.position.y + 2.5;
        const camX = player.position.x + Math.sin(cameraAngle) * cameraDistance;
        const camZ = player.position.z + Math.cos(cameraAngle) * cameraDistance;
        
        camera.position.set(camX, cameraTargetY + 2, camZ);
        camera.lookAt(player.position.x, cameraTargetY, player.position.z);

        renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
